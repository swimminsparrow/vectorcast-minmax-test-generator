package vectorcastesterminmaxgen.CoreFunctions.Parsers;

import java.io.File;
import java.io.IOException;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import org.apache.commons.io.FileUtils;
import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.input.DOMBuilder;
import org.xml.sax.SAXException;
import vectorcastesterminmaxgen.Configs.Constants;
import vectorcastesterminmaxgen.LoggerBoy;
import vectorcastesterminmaxgen.Model.VectorCastEnvironment;
import vectorcastesterminmaxgen.Model.Parameter;
import vectorcastesterminmaxgen.Model.TestCaseXML;
import vectorcastesterminmaxgen.UIUtils.UIDialogs;
import vectorcastesterminmaxgen.UIUtils.UIProgressDialogThread;
import vectorcastesterminmaxgen.Utility.BrowseFileorFolderVCExtension;

/**
 * This Class scans an VectorCastEnvironment Folder to parse all XMLs TestCase files generated by VectorCast.
 * The result of the parsing is an VectorCastEnvironment Object populated with all the information parsed for
 * each testcase of the environment.
 * 
 * @author Roberto Caputo
 * @version 1 11/05/2018
 * @version 2 29/11/2018 Edited to be generic for future library implementation.
 * 
 */

public class SpockXMLTCParser{

    private VectorCastEnvironment vcEnv;

    public SpockXMLTCParser (VectorCastEnvironment vcEnv){
        this.vcEnv = vcEnv;
    }
  
    /**
     * This Function scan the folder containing an environment.
     * @return 
     */
    public VectorCastEnvironment scanEnvironment() {
        ArrayList<TestCaseXML> testcaseList = new ArrayList();
        File envDir = vcEnv.getEnvDir();
        File envSubDir = BrowseFileorFolderVCExtension.getEnvironmentSubFolder(envDir);

        File testCasesDir = null;
        //  folder containing xml testcases //

        if (envSubDir != null && new File(envSubDir.getPath() + "\\TESTCASES\\DATA").isDirectory()) {
            //  store name of environment   //
            testCasesDir = new File(envSubDir.getPath() + "\\TESTCASES\\DATA");
        } else {
            UIDialogs.showErrorDialog(this.getClass(), "Invalid Environment Dir:",
                    envDir.getPath());
        }

        if (testCasesDir != null && envDir != null) {
            //  Hoping is not null  //

            Collection<File> xmlTestCases = FileUtils.listFiles(testCasesDir,
                    Constants.XML_EXTENSIONS, true);
            //  list of xmls testcase files int environment main subfolder  //

            UIProgressDialogThread progressDialogThread = new UIProgressDialogThread("Parsing", xmlTestCases.size(), false);
            // Create Dialog   //

            for (File xmlTestCase : xmlTestCases) {
                //  for each testcase xml   //
                progressDialogThread.updateDialog(xmlTestCase.getPath());
                //Update Dialog //
                testcaseList.add(parseXML(vcEnv.getEnvName(), xmlTestCase));
            }

            vcEnv.setTestcaseXMLList(testcaseList);

            progressDialogThread.closeDialog();
            //Close Progress Dialog //

        }
        
        return vcEnv;
    }
    
    
    /**
     * This Function parses VectorCast TestCase XML specified by xmlTestCase
     * parameter for the specified VectorCastEnvironment env.
     *
     * @param envName VectorCastEnvironment Name considered
     * @param xmlTestCase VectorCast TestCase XML
     * @return TestCase filled with xml data
     */
    
    private TestCaseXML parseXML(String envName, File xmlTestCase){
        TestCaseXML tc = new TestCaseXML();
        tc.setEnvironment(envName);
        try {
            LoggerBoy.logEverywhere(this.getClass().getSimpleName(), "Parsing TestCase... " + xmlTestCase.getPath());
            //creating DOM Document
            DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
            DocumentBuilder dBuilder;
            dBuilder = dbFactory.newDocumentBuilder();
            org.w3c.dom.Document doc = dBuilder.parse(xmlTestCase);
            DOMBuilder domBuilder = new DOMBuilder();
            Document xmlDoc = domBuilder.build(doc);
            //we can create JDOM Document from DOM, SAX and STAX Parser Builder classes

            Element root = xmlDoc.getRootElement();

            tc.setTestcaseName(root.getChildText("name"));
            
            tc.setTESTCASE_ID(Integer.parseInt(root.getChildText("unique_id")));
            
            tc.setUUT_ID(Integer.parseInt(root.getChildText("unit")));
            
            tc.setFUNCTION_ID(Integer.parseInt(root.getChildText("subprogram")));

            switch (root.getChildText("execution_status")) {
                case "TC_EXECUTION_FAILED":
                    tc.setEXECUTION_RESULT(TestCaseXML.EXECUTION_RESULTS.FAILED);
                    break;
                case "TC_EXECUTION_PASSED":
                    tc.setEXECUTION_RESULT(TestCaseXML.EXECUTION_RESULTS.PASSED);
                    break;
                default:
                    tc.setEXECUTION_RESULT(TestCaseXML.EXECUTION_RESULTS.NONE);
                    break;
            }
            
            if (root.getChildText("mcdc_basis_path") != null) {
                tc.setTESTCASE_TYPE(TestCaseXML.TESTCASE_TYPE.MCDC);
            }

            if (root.getChildText("execution") != null) {
                Element executionDate = (Element) root.getChild("execution");
                int month = Integer.parseInt(executionDate.getChildText("month"));
                int day = Integer.parseInt(executionDate.getChildText("day"));
                int year = Integer.parseInt(executionDate.getChildText("year"));

                LocalDate date = LocalDate.of(year, month, day);
                tc.setEXECUTIONDATE(date.toString());
            }

//            if ((root.getChildren("notes")) != null) {
//                ArrayList<String> noteLines = new ArrayList();
//                for (Element noteElement : root.getChildren("notes")) {
//                    String noteLineContent = noteElement.getChildText("notes");
//
//                    noteLines.add(noteLineContent);
//                }
//                tc.setNotes(StringUtils.join(noteLines, "\n"));
//            }
            
            //NOW catch all the input params
            if ((root.getChild("parameter_attributes")) != null){
                List <Element> paramElements = root.getChild("parameter_attributes").getChildren("parameter");
                ArrayList <Parameter> params = new ArrayList();
                for (Element paramElement : paramElements){
                    params.add(new Parameter(paramElement.getChildText("parameter_name"),
                            paramElement.getChildText("input_base")));
                    //remove UUT.subprogram before storing the name of the param    //
                }
                tc.setParameterList(params);
            }

        } catch (IOException | ParserConfigurationException | SAXException ex) {
            LoggerBoy.logError(this.getClass().getSimpleName(), ex.getLocalizedMessage());
        }
        
        return tc;
    }

}
